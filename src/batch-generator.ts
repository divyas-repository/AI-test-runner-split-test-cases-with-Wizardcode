import path from 'path';
import { loadModel, createCompletion } from 'gpt4all';
import fs from 'fs';
import * as XLSX from 'xlsx';

/**
 * Batch Test Generator - Processes test cases in batches of 2
 * 
 * This script generates test cases in small batches to improve quality
 * and avoid timeouts while ensuring all test cases are covered.
 */

interface TestCase {
  id: string;
  title: string;
  description: string;
  steps: string;
  expected: string;
}

// Configuration
const CONFIG = {
  modelsDir: path.join(__dirname, '../Models'),
  modelName: 'mistral-7b-instruct-v0.1.Q2_K.gguf',
  generatedDir: path.join(__dirname, '../generated'),
  batchSize: 2 // Process 2 test cases at a time
};

// Clean LLM output
function cleanLLMOutput(code: string): string {
  code = code.replace(/```[a-zA-Z]*|```/g, '');
  code = code.split('\n').filter(line => {
    const trimmed = line.trim();
    if (!trimmed) return false;
    if (trimmed.startsWith('//') && trimmed.includes('Generated by')) return false;
    if (trimmed.includes('python') || trimmed.includes('def ') || trimmed.includes('import pytest')) return false;
    return true;
  }).join('\n');
  
  return code.trim();
}

// Read test cases from CSV
function readTestCasesFromCSV(filePath: string): TestCase[] {
  try {
    const workbook = XLSX.readFile(filePath);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const data = XLSX.utils.sheet_to_json(worksheet);
    
    const testCases: TestCase[] = [];
    
    data.forEach((row: any, index: number) => {
      if (row['Sl No'] && row['Test Scenario']) {
        const testCase: TestCase = {
          id: `test-case-${row['Sl No']}`,
          title: row['Test Scenario']?.toString().trim() || `Test Case ${index + 1}`,
          description: row['Test Scenario']?.toString().trim() || '',
          steps: row['Test Steps']?.toString().trim() || '',
          expected: row['Expected Result']?.toString().trim() || ''
        };
        
        testCases.push(testCase);
      }
    });
    
    return testCases;
  } catch (error) {
    console.error('‚ùå Error reading CSV file:', error);
    return [];
  }
}

// Build optimized prompt
function buildPrompt(testCase: TestCase): string {
  const lessonsLearned = fs.readFileSync(path.join(__dirname, '../lessons-learned.txt'), 'utf-8');
  
  return `Write a Playwright test function. Use this exact format:

test('${testCase.title}', async ({ page }) => {
  test.setTimeout(120000);
  await page.goto("https://nada-hei.onrender.com/");
  // Add your automation code here
});

CRITICAL: ONLY use https://nada-hei.onrender.com/ - NO OTHER URLS

Test Case Details:
Title: ${testCase.title}
Steps: ${testCase.steps}
Expected Result: ${testCase.expected}

Requirements:
1. Use TypeScript with Playwright
2. Use proper await/async patterns
3. Use getByPlaceholder() for form inputs
4. Use getByRole('button') for buttons
5. Add console.log for debugging
6. NEVER use page.screenshot() calls
7. Handle timeouts properly
8. Use .first() for multiple elements

Lessons Learned:
${lessonsLearned}

Generate only the test function code:`;
}

// Generate test for a single test case
async function generateSingleTest(model: any, testCase: TestCase): Promise<string> {
  const prompt = buildPrompt(testCase);
  
  console.log(`\n--- Generating: ${testCase.title} ---`);
  console.log(`‚è±Ô∏è Starting LLM generation (max 120s timeout)...`);
  
  try {
    const completionPromise = createCompletion(model, prompt);
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('LLM generation timeout after 120s')), 120000)
    );
    
    const res = await Promise.race([completionPromise, timeoutPromise]) as any;
    
    let generatedCode = '';
    if (res && res.choices && res.choices[0] && res.choices[0].message && res.choices[0].message.content) {
      generatedCode = res.choices[0].message.content;
    } else {
      console.log('‚ö†Ô∏è No LLM output received, using fallback');
    }
    
    const cleanedCode = cleanLLMOutput(generatedCode);
    console.log(`‚úÖ Generated test (${cleanedCode.length} chars)`);
    
    return cleanedCode;
  } catch (error) {
    console.error(`‚ùå Generation failed for ${testCase.title}:`, error);
    return `test('${testCase.title}', async ({ page }) => {
  test.setTimeout(120000);
  await page.goto("https://nada-hei.onrender.com/");
  
  // TODO: Implementation needed for ${testCase.title}
  // Steps: ${testCase.steps}
  // Expected: ${testCase.expected}
  
  console.log('‚ö†Ô∏è Test implementation pending');
});`;
  }
}

// Generate batch of tests
async function generateBatch(model: any, testCases: TestCase[], batchNumber: number): Promise<void> {
  console.log(`\nüöÄ Generating Batch ${batchNumber} (${testCases.length} test cases)`);
  
  const testCodes: string[] = [];
  
  for (const testCase of testCases) {
    const testCode = await generateSingleTest(model, testCase);
    testCodes.push(testCode);
  }
  
  // Create batch file
  const batchFileName = `test-batch-${batchNumber}.ts`;
  const batchFilePath = path.join(CONFIG.generatedDir, batchFileName);
  
  const fileContent = `import { test, expect } from '@playwright/test';

describe('Test Batch ${batchNumber}', () => {
${testCodes.join('\n\n')}
});
`;
  
  fs.writeFileSync(batchFilePath, fileContent);
  console.log(`‚úÖ Generated ${batchFileName} with ${testCases.length} tests`);
}

// Main batch generation function
async function generateInBatches(csvFilePath: string): Promise<void> {
  console.log('üßπ Starting batch test generation...');
  
  // Read test cases
  const allTestCases = readTestCasesFromCSV(csvFilePath);
  console.log(`üìä Found ${allTestCases.length} test cases in CSV`);
  
  if (allTestCases.length === 0) {
    console.error('‚ùå No test cases found in CSV file');
    return;
  }
  
  // Load LLM model
  console.log('üì¶ Loading Mistral model...');
  const modelPath = path.join(CONFIG.modelsDir, CONFIG.modelName);
  
  if (!fs.existsSync(modelPath)) {
    console.error(`‚ùå Model not found at: ${modelPath}`);
    return;
  }
  
  const model = await loadModel(CONFIG.modelName, {
    verbose: true,
    modelPath: CONFIG.modelsDir,
    nCtx: 2048
  });
  console.log('‚úÖ Model loaded successfully');
  
  // Ensure generated directory exists
  if (!fs.existsSync(CONFIG.generatedDir)) {
    fs.mkdirSync(CONFIG.generatedDir, { recursive: true });
  }
  
  // Process in batches
  const totalBatches = Math.ceil(allTestCases.length / CONFIG.batchSize);
  console.log(`üìù Processing ${allTestCases.length} test cases in ${totalBatches} batches of ${CONFIG.batchSize}`);
  
  for (let i = 0; i < totalBatches; i++) {
    const batchStart = i * CONFIG.batchSize;
    const batchEnd = Math.min(batchStart + CONFIG.batchSize, allTestCases.length);
    const batchTestCases = allTestCases.slice(batchStart, batchEnd);
    
    await generateBatch(model, batchTestCases, i + 1);
    
    // Small delay between batches
    if (i < totalBatches - 1) {
      console.log('‚è≥ Waiting 2 seconds before next batch...');
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  
  console.log(`\nüéâ Batch generation complete! Generated ${totalBatches} batch files.`);
}

// CLI execution
if (require.main === module) {
  const csvFilePath = process.argv[2];
  if (!csvFilePath) {
    console.error('‚ùå Please provide CSV file path as argument');
    process.exit(1);
  }
  
  generateInBatches(csvFilePath)
    .then(() => {
      console.log('‚úÖ All batches completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Batch generation failed:', error);
      process.exit(1);
    });
}

export { generateInBatches };
